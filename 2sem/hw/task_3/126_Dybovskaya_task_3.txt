QuickSort.java |12| int base = split(data, e, b); -> int base = split(data, b, e); |quickSort_sortArrayWithTwoNumbers_SortCorrect
QuickSort.java |24| swap(data, left, baseElem); -> swap(data, left - 1, baseElem); |quickSort_sortArrayWithTwoNumbers_SortCorrect
QuickSort.java |13| qSortRec(data, b, base - 2); -> qSortRec(data, b, base - 1); |quickSort_sortArrayWithTwoNumbers_SortCorrect # очень странная штука- после исправления 12 24 все до единого теста работают- ошибок нет- видимо необходимо 13 14 блоком вместе с первым тестом (12 24) обнаружить иначе в сл.тестах нет толку.
QuickSort.java |14| qSortRec(data, base + 2, e); -> qSortRec(data, base + 1, e); |quickSort_sortArrayWithTwoNumbers_SortCorrect
QuickSort.java |25| baseElem = left; -> baseElem = left-1; |QuickSort_sortArrayWithSameNumbers_SortCorrect # тоже странная штука-25 и 29 в паре, тк если исп только 25 то получается цикл и тесты крутятся не выдавая результата
QuickSort.java |29| swap(data, left+1, right);-> swap(data, left, right); |QuickSort_sortArrayWithSameNumbers_SortCorrect # отдельно 29 без 25 крушит другие тесты, так что они идут в паре

MergeSort.java || |
MergeSort.java || |
MergeSort.java || |
MergeSort.java || |

HeapSort.java |10| swap(0, data.length - sortedSize); -> swap(0, data.length - sortedSize - 1); | HeapSort_SortNotNeed_SortCorrect # выдает Index 2 out of bounds for length 2
HeapSort.java |17| for (int i = start; i >= 1; --i) -> for (int i = start; i >= 0; --i) | HeapSort_sortArrayDifNumbers_SortCorrect
HeapSort.java |18| siftDown(i, 2 * i, 2 * i + 1, data.length); -> siftDown(i, 2 * i+1, 2 * i + 2, data.length); | HeapSort_SortNotNeed_NumbersOnRightPositions
HeapSort.java |38| siftDown(right, 2 * right + 1, 2 * right + 2, data.length); -> siftDown(right, 2 * right + 1, 2 * right + 2, size); | HeapSort_sortArrayB_SortCorrect
HeapSort.java |34| siftDown(left, 2 * left, 2 * left + 1, size); -> siftDown(left, 2 * left+1, 2 * left + 2, size); | HeapSort_sortArrayB_SortCorrect